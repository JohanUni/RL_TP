# -*- coding: utf-8 -*-
"""Ambiente_RL_Trabajo_Parcial_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bpp7B5GoEDjXDEQH8lqLq9XSPP0wDLJP

## **Trabajo Parcial**
 **Curso:**  Aprendizaje por Reforzamiento (2024-2 A)

 **Sección:** A

 **Grupo N°:** 8

 **Integrantes:**

> - Boza Gutarra, Fernando
- Callomamani Buendia, Johan Manuel
- De La Cruz, Lewis
- Gomez Villanueva, Kevin
- Romero Ramos, Yovany
"""

import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import numpy as np

def plot_start_state(ax = {(1, 7), (4, 6), (8, 10), (9, 9), (10, 8)}):
  # Crear el entorno (12x12 grid, con padding de 1 grilla extra alrededor)
  grid_size = (12, 12)  # Incluye el padding
  grid = np.zeros(grid_size)

  # Definir color del fondo, padding y obstáculos
  bg_color = "#003f4f"  # Color proporcionado para el fondo
  padding_color = "#003040"  # Color ligeramente más oscuro para padding y obstáculos
  obstacle_color = "#003040"
  border_color = "white"

  # Definir obstáculos en columnas completas (con padding incluido)
  obstacle_positions = []
  for col in range(3, grid_size[1] - 1, 2):  # Cada 2 columnas, desde 3 (con padding)
      for row in range(3, 9):  # Filas entre 3 y 8 (con padding)
          obstacle_positions.append((row, col))

  # Generar posiciones aleatorias para recompensas, evitando padding y obstáculos
  reward_positions = set()

  np.random.seed()  # Semilla aleatoria
  num_rewards = 5  # Número total de manchas
  while len(reward_positions) < num_rewards:
      pos = (
          np.random.randint(1, grid_size[0] - 1),  # Evitar padding
          np.random.randint(1, grid_size[1] - 1),
      )
      if pos not in obstacle_positions and pos not in reward_positions:
          reward_positions.add(pos)
  reward_positions =  ax ## MODIFICAR AQUI
  # Cargar imágenes del robot y la mancha
  robot_icon = mpimg.imread("robot1.png")
  mancha_icon = mpimg.imread("mancha.png")

  # Crear el gráfico con el fondo proporcionado
  fig, ax = plt.subplots(figsize=(3, 3))
  ax.set_facecolor(bg_color)
  ax.set_xticks(np.arange(0, 13))
  ax.set_yticks(np.arange(0, 13))
  ax.grid(color="black", linestyle="-", linewidth=0.5)

  # Dibujar el padding y el fondo
  for i in range(grid.shape[0]):
      for j in range(grid.shape[1]):
          if i == 0 or i == grid_size[0] - 1 or j == 0 or j == grid_size[1] - 1:  # Padding
              ax.add_patch(plt.Rectangle((j, i), 1, 1, color=padding_color, ec=border_color, zorder=2))
          else:  # Celdas internas
              ax.add_patch(plt.Rectangle((j, i), 1, 1, color=bg_color, ec=None))

  # Dibujar recompensas (manchas) sin rotar
  for reward_pos in reward_positions:
      ax.imshow(mancha_icon, extent=(reward_pos[1], reward_pos[1] + 1, reward_pos[0], reward_pos[0] + 1), zorder=10, origin='lower')

  # Dibujar obstáculos con bordes blancos
  for obstacle_pos in obstacle_positions:
      ax.add_patch(plt.Rectangle((obstacle_pos[1], obstacle_pos[0]), 1, 1, color=obstacle_color, ec=border_color, zorder=5))

  # Mostrar posición del robot correctamente orientado
  robot_pos = (1, 1)  # Fila 1, columna 1 (con padding)
  ax.imshow(robot_icon, extent=(robot_pos[1], robot_pos[1] + 1, robot_pos[0], robot_pos[0] + 1), zorder=15, origin='lower')

  # Ajustar límites
  plt.xlim(0, grid_size[1])
  plt.ylim(0, grid_size[0])
  plt.gca().invert_yaxis()  # Invertir eje Y para orientación correcta

  plt.show()

plot_start_state()

plot_start_state(ax = {(4, 6), (8, 10), (9, 9)})

